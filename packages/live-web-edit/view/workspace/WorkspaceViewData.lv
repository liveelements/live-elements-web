import .lib.middle

component WorkspaceViewData{

    static Object WriteBehavior = {
        ReadOnly: 0,
        Write: 1,
        Fork: 2
    }

    string baseUrl: ''
    Array<Document> documents: []
    Array<Object> editors: []
    string workspaceName: ''
    number writeBehavior: WorkspaceViewData.WriteBehavior.Write
    string lastCompilation: null
    string workspaceViewUrl: null
    bool workspaceSelector: false
    Object loadingStatus: null
    boolean frameLoading: false
    Array<Object> templates: []
    Array<Object> errors: []
    Array<Object> logMessages: []
    Object serverRoutes: ({})

    string workspaceFrameSrc: ''
    number workspaceFrameRev: 0

    fn writeEnabled():boolean{ 
        return this.writeBehavior === WorkspaceViewData.WriteBehavior.Write || this.writeBehavior === WorkspaceViewData.WriteBehavior.Fork
    }
    fn lockEnabled():boolean{
        return this.writeBehavior === WorkspaceViewData.WriteBehavior.Write
    }
    fn route(url:string):string{ return this.baseUrl + url }

    fn appendLogMessage(message:string){
        while ( this.logMessages.length > 50 ){
            this.logMessages.shift()
        }
        this.logMessages.push(message)
        this.logMessagesChanged.emit()
    }

    fn appendHistory(state:Object, route:string){
        window.history.pushState(state, null, route)
    }

    fn updateFromJSON(data:Object){
        this.baseUrl = data.baseUrl ? data.baseUrl : this.baseUrl
        this.workspaceName = data.name
        this.workspaceViewUrl = this.workspaceName
        if ( data.documents ){
            data.documents.forEach(dataDocument => {
                const doc = this.documents.find(d => d.path === dataDocument.path)
                if ( doc ){
                    const isReset = doc.content !== dataDocument.content
                    doc.content = dataDocument.content
                    if ( isReset )
                        doc.contentReset.emit()
                } else {
                    this.documents = this.documents.concat([Document.fromJSON(dataDocument)])
                }
            })
            let toRemove = []
            this.documents.forEach(thisDocument => {
                const dataDoc = data.documents.find(d => d.path === thisDocument.path)
                if ( !dataDoc ){
                    toRemove.push(dataDoc)
                }
            })
            toRemove.forEach(removeDoc => {
                this.documents = this.documents.filter(d => d === removeDoc)
            })
            this.editors = this.documents.map((doc, i) => ({ document: doc, isActive: i === 0}))
        }
        this.writeBehavior = data.writeBehavior ? data.writeBehavior : this.writeBehavior
        this.lastCompilation = data.compilation ? data.compilation : this.lastCompilation
        this.templates = data.templates ? data.templates : this.templates
        this.errors = data.errors 
            ? data.errors 
            : data.error ? [data.error] 
                : data.compilation && data.compilation.errors ? data.compilation.errors 
                : this.errors
    }

    static fn fromJSON(data:Object):WorkspaceViewData{
        const baseUrl = data.baseUrl ? data.baseUrl : ''
        return WorkspaceViewData{    
            baseUrl = data.baseUrl ? data.baseUrl : ''
            workspaceName = data.name
            documents = data.documents ? data.documents.map(ddoc => Document.fromJSON(ddoc)) : []
            writeBehavior = data.writeBehavior
            lastCompilation = data.compilation ? data.compilation : null
            templates = data.templates ? data.templates : []
            serverRoutes = ({
                load: `${baseUrl}/w-load`,
                save: `${baseUrl}/w-document/save/:workspace`,
                compile: `${baseUrl}/w-compile/:workspace`,
                lockWrite: `${baseUrl}/w-lockwrite/:workspace`,
                fork: `${baseUrl}/w-fork/:workspace`
            })
            workspaceFrameSrc = ''
            workspaceFrameRev = 0
            errors = data.errors 
                ? data.errors 
                : data.error ? [data.error] 
                    : data.compilation && data.compilation.errors 
                        ? data.compilation.errors 
                        : []
        }
    }
}